var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
import { setupAngular } from './_setup';
import gql from 'graphql-tag';
import { TestBed, inject, async } from '@angular/core/testing';
import { Observable } from 'rxjs/Observable';
import { InMemoryCache } from 'apollo-cache-inmemory';
import { Apollo, ApolloBase } from '../src/Apollo';
import { mockSingleLink } from './mocks/mockLinks';
function mockApollo(link, options) {
    var apollo = new Apollo();
    apollo.create(__assign({ link: link, cache: new InMemoryCache() }, options));
    return apollo;
}
describe('Apollo', function () {
    beforeAll(function () { return setupAngular(); });
    beforeEach(function () {
        TestBed.configureTestingModule({
            providers: [Apollo],
        });
    });
    describe('default()', function () {
        test('should return the default client', function () {
            var apollo = new Apollo();
            apollo.create({});
            expect(apollo.default() instanceof ApolloBase).toBe(true);
            expect(apollo.default().getClient()).toBeDefined();
        });
    });
    describe('use()', function () {
        test('should use a named client', function () {
            var apollo = new Apollo();
            apollo.create({}, 'extra');
            expect(apollo.use('extra') instanceof ApolloBase).toBe(true);
            expect(apollo.use('extra').getClient()).toBeDefined();
        });
    });
    describe('watchQuery()', function () {
        test('should be called with the same options', function () {
            var apollo = new Apollo();
            apollo.create({});
            var client = apollo.getClient();
            var options = { query: 'gql' };
            client.watchQuery = jest.fn().mockReturnValue(new Observable());
            apollo.watchQuery(options);
            expect(client.watchQuery).toBeCalledWith(options);
        });
        test('should be able to refetch', function (done) {
            var query = (_a = ["\n        query refetch($first: Int) {\n          heroes(first: $first) {\n            name\n            __typename\n          }\n        }\n      "], _a.raw = ["\n        query refetch($first: Int) {\n          heroes(first: $first) {\n            name\n            __typename\n          }\n        }\n      "], gql(_a));
            var data1 = { heroes: [{ name: 'Foo', __typename: 'Hero' }] };
            var variables1 = { first: 0 };
            var data2 = { heroes: [{ name: 'Bar', __typename: 'Hero' }] };
            var variables2 = { first: 1 };
            var link = mockSingleLink({
                request: { query: query, variables: variables1 },
                result: { data: data1 },
            }, {
                request: { query: query, variables: variables2 },
                result: { data: data2 },
            });
            var apollo = mockApollo(link);
            var options = { query: query, variables: variables1 };
            var obs = apollo.watchQuery(options);
            var calls = 0;
            obs.valueChanges.subscribe({
                next: function (_a) {
                    var data = _a.data;
                    calls++;
                    try {
                        if (calls === 1) {
                            expect(data).toMatchObject(data1);
                        }
                        else if (calls === 3) {
                            // 3 because there is an intermediate loading state
                            expect(data).toMatchObject(data2);
                        }
                        else if (calls > 3) {
                            throw new Error('Called third time');
                        }
                    }
                    catch (e) {
                        done.fail(e);
                    }
                },
                error: function (err) {
                    done.fail(err);
                },
            });
            setTimeout(function () {
                obs.refetch(variables2).then(function (_a) {
                    var data = _a.data;
                    try {
                        expect(data).toMatchObject(data2);
                        done();
                    }
                    catch (e) {
                        done.fail(e);
                    }
                });
            });
            var _a;
        });
    });
    describe('query()', function () {
        test('should be called with the same options', function (done) {
            var apollo = new Apollo();
            apollo.create({});
            var client = apollo.getClient();
            var options = { query: 'gql' };
            client.query = jest.fn().mockReturnValue(Promise.resolve('query'));
            var obs = apollo.query(options);
            obs.subscribe({
                next: function (r) {
                    expect(r).toEqual('query');
                    expect(client.query).toBeCalledWith(options);
                    done();
                },
                error: function () {
                    done.fail('should not be called');
                },
            });
        });
        test('should not be called without subscribing to it', function (done) {
            var apollo = new Apollo();
            apollo.create({});
            var client = apollo.getClient();
            client.query = jest.fn().mockReturnValue(Promise.resolve('query'));
            var obs = apollo.query({});
            expect(client.query).not.toBeCalled();
            obs.subscribe({
                complete: function () {
                    expect(client.query).toBeCalled();
                    done();
                },
            });
        });
    });
    describe('mutate()', function () {
        test('should be called with the same options', function (done) {
            var apollo = new Apollo();
            apollo.create({});
            var client = apollo.getClient();
            var options = { mutation: 'gql' };
            client.mutate = jest.fn().mockReturnValue(Promise.resolve('mutation'));
            var obs = apollo.mutate(options);
            obs.subscribe({
                next: function (r) {
                    expect(r).toEqual('mutation');
                    expect(client.mutate).toBeCalledWith(options);
                    done();
                },
                error: function () {
                    done.fail('should not be called');
                },
            });
        });
        test('should not be called without subscribing to it', function (done) {
            var apollo = new Apollo();
            apollo.create({});
            var client = apollo.getClient();
            client.mutate = jest.fn().mockReturnValue(Promise.resolve('mutation'));
            var obs = apollo.mutate({});
            expect(client.mutate).not.toBeCalled();
            obs.subscribe({
                complete: function () {
                    expect(client.mutate).toBeCalled();
                    done();
                },
            });
        });
    });
    describe('subscribe', function () {
        test('should be called with the same options and return Observable', function (done) {
            var apollo = new Apollo();
            apollo.create({});
            var client = apollo.getClient();
            client.subscribe = jest.fn().mockReturnValue(['subscription']);
            var options = { query: 'gql' };
            var obs = apollo.subscribe(options);
            expect(client.subscribe).toBeCalledWith(options);
            obs.subscribe({
                next: function (result) {
                    expect(result).toBe('subscription');
                    done();
                },
                error: function () {
                    done.fail('should not be called');
                },
            });
        });
    });
    describe('query updates', function () {
        test('should update a query after mutation', function (done) {
            var query = (_a = ["\n        query heroes {\n          allHeroes {\n            name\n            __typename\n          }\n        }\n      "], _a.raw = ["\n        query heroes {\n          allHeroes {\n            name\n            __typename\n          }\n        }\n      "], gql(_a));
            var mutation = (_b = ["\n        mutation addHero($name: String!) {\n          addHero(name: $name) {\n            name\n            __typename\n          }\n        }\n      "], _b.raw = ["\n        mutation addHero($name: String!) {\n          addHero(name: $name) {\n            name\n            __typename\n          }\n        }\n      "], gql(_b));
            var variables = { name: 'Bar' };
            // tslint:disable:variable-name
            var __typename = 'Hero';
            var FooHero = { name: 'Foo', __typename: __typename };
            var BarHero = { name: 'Bar', __typename: __typename };
            var data1 = { allHeroes: [FooHero] };
            var dataMutation = { addHero: BarHero };
            var data2 = { allHeroes: [FooHero, BarHero] };
            var link = mockSingleLink({
                request: { query: query },
                result: { data: data1 },
            }, {
                request: { query: mutation, variables: variables },
                result: { data: dataMutation },
            });
            var apollo = mockApollo(link);
            var obs = apollo.watchQuery({ query: query });
            var calls = 0;
            obs.valueChanges.subscribe(function (_a) {
                var data = _a.data;
                calls++;
                if (calls === 1) {
                    expect(data).toMatchObject(data1);
                    apollo
                        .mutate({
                        mutation: mutation,
                        variables: variables,
                        updateQueries: {
                            heroes: function (prev, _a) {
                                var mutationResult = _a.mutationResult;
                                return {
                                    allHeroes: prev.allHeroes.concat([mutationResult.data.addHero]),
                                };
                            },
                        },
                    })
                        .subscribe({
                        next: function (result) {
                            expect(result.data.addHero).toMatchObject(BarHero);
                        },
                        error: function (error) {
                            done.fail(error.message);
                        },
                    });
                }
                else if (calls === 2) {
                    expect(data).toMatchObject(data2);
                    done();
                }
            });
            var _a, _b;
        });
        test('should update a query with Optimistic Response after mutation', function (done) {
            var query = (_a = ["\n        query heroes {\n          allHeroes {\n            id\n            name\n            __typename\n          }\n        }\n      "], _a.raw = ["\n        query heroes {\n          allHeroes {\n            id\n            name\n            __typename\n          }\n        }\n      "], gql(_a));
            var mutation = (_b = ["\n        mutation addHero($name: String!) {\n          addHero(name: $name) {\n            id\n            name\n            __typename\n          }\n        }\n      "], _b.raw = ["\n        mutation addHero($name: String!) {\n          addHero(name: $name) {\n            id\n            name\n            __typename\n          }\n        }\n      "], gql(_b));
            var variables = { name: 'Bar' };
            var __typename = 'Hero';
            var FooHero = { id: 1, name: 'Foo', __typename: __typename };
            var BarHero = { id: 2, name: 'Bar', __typename: __typename };
            var OptimisticHero = { id: null, name: 'Temp', __typename: __typename };
            var data1 = { allHeroes: [FooHero] };
            var dataMutation = { addHero: BarHero };
            var data2 = { allHeroes: [FooHero, OptimisticHero] };
            var data3 = { allHeroes: [FooHero, BarHero] };
            var link = mockSingleLink({
                request: { query: query },
                result: { data: data1 },
            }, {
                request: { query: mutation, variables: variables },
                result: { data: dataMutation },
            });
            var apollo = mockApollo(link);
            var obs = apollo.watchQuery({ query: query });
            var calls = 0;
            obs.valueChanges.subscribe(function (_a) {
                var data = _a.data;
                calls++;
                if (calls === 1) {
                    expect(data).toMatchObject(data1);
                    apollo
                        .mutate({
                        mutation: mutation,
                        variables: variables,
                        optimisticResponse: {
                            addHero: OptimisticHero,
                        },
                        updateQueries: {
                            heroes: function (prev, _a) {
                                var mutationResult = _a.mutationResult;
                                return {
                                    allHeroes: prev.allHeroes.concat([mutationResult.data.addHero]),
                                };
                            },
                        },
                    })
                        .subscribe({
                        error: function (error) {
                            done.fail(error.message);
                        },
                    });
                }
                else if (calls === 2) {
                    expect(data).toMatchObject(data2);
                }
                else if (calls === 3) {
                    expect(data).toMatchObject(data3);
                    done();
                }
            });
            var _a, _b;
        });
    });
    test('should use HttpClient', async(inject([Apollo], function (apollo) {
        var op = {
            query: (_a = ["\n            query heroes {\n              heroes {\n                name\n                __typename\n              }\n            }\n          "], _a.raw = ["\n            query heroes {\n              heroes {\n                name\n                __typename\n              }\n            }\n          "], gql(_a)),
            variables: {},
        };
        var data = {
            heroes: [
                {
                    name: 'Superman',
                    __typename: 'Hero',
                },
            ],
        };
        // create
        apollo.create({
            link: mockSingleLink({ request: op, result: { data: data } }),
            cache: new InMemoryCache(),
        });
        // query
        apollo.query(op).subscribe({
            next: function (result) {
                expect(result.data).toMatchObject(data);
            },
            error: function (e) {
                throw new Error(e);
            },
        });
        var _a;
    })));
});
//# sourceMappingURL=Apollo.spec.js.map